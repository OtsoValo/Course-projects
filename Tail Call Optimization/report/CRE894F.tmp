\documentclass{tufte-handout}

\usepackage{report}

\begin{document}
\thispagestyle{empty}
\maketitle% this prints the handout title, author, and date

\begin{abstract}
\noindent This project aims to implement tail call optimization for \textit{Juice}, a compiler from Joos\footnote{Joos (Java's Object Oriented Subset) is a subset of Java used for teaching and research.} to Assembly. Tail call optimization allows writing deeply recursive functions without getting a stack overflow.
\end{abstract}

\section{Introduction}

A \textit{tail call}%\marginnote{What is a tail call?}
\ is a call site, i.e.~a line with a function call, in tail position. A call site is said to be in \textit{tail position} when it is the last action that a procedure has to perform before returning.

A function is called \textit{tail recursive}%\marginnote{tail recursion}
if it invokes itself in a tail call. Tail recursion is an important type of tail calls. 
For example, let's consider a function in Haskell that calculates Fibonucci numbers:

\inputMinted{haskell}{fibo1.hs}

\noindent In line 3, \verb'fibo' calls itself recursively two times. After the recursive call of \verb'fibo(n - 1)' is performed, it has to be added to the result of \verb'fibo(n - 2)'. The recursive call is
not the last action performed before the result of \verb'fibo(n - 1)' is returned, and therefore this is not a case of tail recursion. Moreover, we have to recalculate \verb'fibo(n - 2)' in the next recursive call of \verb'fibo(n - 1)' which makes our Fibonacci numbers function grow exponentially.

Every time \verb'fibo' calls itself recursively, a new stack frame is allocated on the call stack, which can cause a stack overflow, even for small values of \verb'n' like 50. The function needs to be rewritten, such that the evaluation of every previous member of the sequence is done only once. This can be done easily by using accumulators and taile recursion:

\inputMinted{haskell}{fact2.hs}

\noindent Running this code will reveal that no stack overflow occurs even for large values of~\verb'n': e.g. the result of \verb'fibo 100000' will be calculated right away. Besides the linear complexity of that algorithm, the reason for the better performance is due to \textit{tail call optimization} (TCO) that is performed by the Haskell compiler.
Because the return value of \verb'fibo2' is the return value of the tail call, we can pop \verb'fibo2''s stack frame from the call stack, push the stack frame for the tail call, and replace the tail call's return address with \verb'fibo2''s return address. For a large sequence of tail calls, this optimization saves a significant amount of memory on the stack. 

%REPHRASE
\section{Motivation}
Unlike compilers of functional languages, the Java Virtual Machine does not support TCO. 

However, as argued by Matthias Felleisen\footnote{One of the creators of the Racket programming language}, ``a language should implement TCO in support of proper design''\footnote{Comment on J. Rose's, ``Tail calls in the VM'' article, \href{https://blogs.oracle.com/jrose/entry/tail_calls_in_the_vm}{blogs.oracle.com/jrose/entry/tail\_calls\_in\_the\_vm}}. The reason is that the implementation of many object-oriented design patterns in Java will likely result in stack overflows even when all methods use tail recursion: ``Java isn't TCO [...], meaning it doesn't allow programmers to design according  
to OO principles.''

As an example, let's look at the object-oriented principle of using Class Hierarchies for Unions\footnote{Bloch, J. ``Effective Java.'' Prentice Hall, 2008.} that Felleisen demonstrated at the 18th ECOOP\footnote{European Conference on Object-Oriented Programming, 2004, Oslo}.
To implement a list data structure, we create an abstract class \verb'List<T>' that can either be \verb'Empty' or a pair \verb'Cons' of an element of type \verb'T' and the rest of the list:

\inputMinted{java}{list.java}

If we run a test program

\inputMinted{java}{test.java}

\noindent on \verb'main(100000)', we get a StackOverflowError which would not happen if Java supported tail call optimization. The same test in a Haskell program as follows runs just fine:

\inputMinted{haskell}{list.hs}

The problem with implementing TCO in Java is that the Java Virtual Machine (JVM) supports \textit{stack inspection} which invalidates program transformations like TCO\footnote{Fournet, Cedric, Gordon. ``Stack inspection: Theory and variants.'' ACM SIGPLAN Notices 37.1 (2002): 307-318.}.

The objective of this project is to implement TCO for Joos. Joos is a subset of Java that does not compile to the JVM and does not have the mentioned limitations that would hinder us from implementing TCO.

\section{Implementation}
We considered a statement to be in tail posistion according to the following definition:
\begin{definition}[Tail call]
  A method invocation $m$ is considered to be a tail call if satisfies one of the following conditions:
  \begin{enumerate}
    \item It is the right-hand side of a \verb'return' statement in a non-void method\footnote{\verb'return' $m$\verb';'};
    \item It is a full statement in a void method and is immediately followed by a \verb'return' statement\footnote{$m$\verb';'\\\verb'return;'};
    \item It is the last statement of a method.
  \end{enumerate}
\end{definition}
\begin{definition}[Last statement]
  A statement $s$ is said to be the last statement of another statement\footnote{A statement can be a single or compound statement.} $b$ in one of the following cases:
  \begin{enumerate}
    \item If $b$ is a single statement, and $s=b$.
    \item If $b$ is a sequence of statements $s_1,\,\dots,\,s_n$, and $s=s_n$.
    \item If $b$ is a conditional statement: $b=$\verb'if('<condition>\verb') { '$t$\verb' } else { '$e$\verb' }', where $t$ and $e$ are statements, and $s$ is the last statement of $t$ or of $e$.
    \item If $b$ is a while loop: $b=$\verb'while('<condition>\verb') { '$l$\verb' }', where $l$ is a statement, and $s$ is the last statement of $l$.
    \item If $b$ is a for loop: $b=$\verb'for('<for init>; <condition>; <for update>\verb') { '$l$\verb' }', where $l$ is a statement, and $s$ is the last statement of $l$.
  \end{enumerate}
\end{definition}

%In Joos, a tail position is the right-hand side of a \verb'return' statment%
%\footnote{In Java, if the return statement were in a 'try/catch'
%block, the tail position would depend on the existence of a 'finally' block.}
%. Hence, a function call $f(a_1,\,\dots,\,a_n)$ will be in tail position if it is the argument of a \verb'return' statement.


\nocite{*}	% causes all the references in the bib file to be included

\end{document}

\begin{fullwidth}
\bibliography{bib}
\end{fullwidth}
\end{document}
